#!/usr/bin/python
"""Phoenix power control"""
# vim: tabstop=4 shiftwidth=4 softtabstop=4

import sys
import argparse
import logging
from ClusterShell.NodeSet import NodeSet, set_std_group_resolver_config
from ClusterShell.Task import task_self, Task
from ClusterShell.CLI.Config import ClushConfig, ClushConfigError
from ClusterShell.CLI.Error import GENERIC_ERRORS, handle_generic_error
from ClusterShell.CLI.Display import Display, sys_stdin

import phoenix
from phoenix.Node import Node
from phoenix.Generic import _do_redfish_req,phoenix_int_handler,phoenix_clustershell_cleanup,run_clustershell_command,run_local_threaded_command

import concurrent.futures
import requests
#only need os and inspect for debugging, and time
import os
import inspect
import time

# This is needed to turn off SSL warnings
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


#psutil is not easy to get for suse 12 without internet...
##kill all futures then sigint to clean up clustershell threads with phoenix_clustershell_cleanup, if there are any
#def phoenix_terminate_all(pid, future_executor):
#
#  future_executor.shutdown(wait=False)
#
#  try:
#    parent = psutil.Process(pid)
#  except psutil.NoSuchProcess:
#    print "We should never be here."
#    return
#  children = parent.children(recursive=True) #just in case threads called threads
#  for process in children:
#    process.send_signal(signal.SIGINT)


def get_parser():
  parser = argparse.ArgumentParser(prog="phoenix_power", description="Control the power of Phoenix nodes")
  parser.add_argument('nodes', help='Nodes to control', type=str)
  parser.add_argument('state', help='Desired state', type=str)
  parser.add_argument('--cs', '--clustershell_arg', help='Optional Clustershell args.', type=str)
  parser.add_argument('-v', '--verbose', action='count', default=0)
  parser.add_argument('-w', '--worker', action='count', default=0)
  return parser


#a function that gets called by run_threaded_command must accept a list of args and a list of nodes
#TODO: have power call _do_req, and have _do_req be generic for all redfish requests
#def _do_redfish_req(node, request_type, path="", data={}, header={}):
def power(node, arglist=[]):
  """
  POWWWAAAAAHH
  https://media0.giphy.com/media/Ixx5oJTLtmrgQ/giphy.gif
  """
  # Normalize the requested state
  state = arglist[0].lower() #the only arg is state
  logging.debug("state: {0}".format(state))
  headers = { 'Content-Type': 'application/json' }

  #TODO: have requests operate on whether or not you have certain fields
  if state in ['stat', 'state', 'status']:
    response = _do_redfish_req(node, "get")
    rjson = response.json()
    return "%s: %s" % (node, rjson['PowerState'])

  elif state in ['on']:
    data = { 'ResetType': 'On' }
    path = '/Actions/ComputerSystem.Reset'
    response = _do_redfish_req(node, "post", path, data, headers)
  elif state in ['off']:
    data = { 'ResetType': 'ForceOff' }
    path = '/Actions/ComputerSystem.Reset'
    response = _do_redfish_req(node, "post", path, data, headers)
  #elif state in ['reset', 'restart']:
  #  data = { 'ResetType': 'ForceRestart' }
  #  path = 'Actions/ComputerSystem.Reset'
  #  response = _do_redfish_req(node, "post", path, data, headers)
  else:
    return "%s Invalid Node State, ie. On, Off, Restart, Status" % (node)

  # Current NCs are returning a 204 - need to test if this makes sense
  # Also figure out what an error response looks like and return it
  if response == -1:
    return "%s: Failed - status -1 (this is a phoenix error)" % (node)
  elif response.status_code == 200 or response.status_code == 204:
    #TODO: this should probably be more specific
    return "%s: Ok" % node
  else:
    return "%s: Failed - status %d" % (node, response.status_code)


#runs threaded commands on a service node
def run_local_threaded_command(function, cs_ns, arglist=[]):
  """
  Function is the function that we will parallelize.
  arglist is a list of arguments for the function.
  cs_ns is a hostlist of all nodes that we will run the function against.
  """

  rc = 0
  Node.load_nodes(nodeset=cs_ns)

  timeout = 60 #this is the futures timeout. We want requests to timeout first, than futures, then clustershell.
  threads = len(cs_ns)
  executor = concurrent.futures.ThreadPoolExecutor(max_workers = threads, thread_name_prefix='clustershell_phoenix_worker')

  futurelist = []
  for node in cs_ns:
    futurelist.append(executor.submit(function, node, arglist))

  try:
    for future in concurrent.futures.as_completed(futurelist, timeout=timeout):
      try:
        data = future.result()
      except Exception as exc:
        print "Error: %s" % exc
      else:
        print data
  except concurrent.futures.TimeoutError:
    print "Timeout on a node.".format(node)
    rc = rc + 1
    #we can't kill these things without waiting for them :(
    ##catching the exception will end the loop anyway, so let's end it all
    #phoenix_terminate_all(os.getpid(), executor)
  return rc


if __name__ == '__main__':
  phoenix_int_handler()
  set_std_group_resolver_config('/etc/clustershell/groups.conf.d/phoenix.conf')
  parser = get_parser()
  args = parser.parse_args()
  phoenix.setup_logging(args.verbose)

  verbose= "-" * (args.verbose > 0) + "v" * args.verbose 
  arguments = [args.state, verbose]
  #print arguments

  #TODO: We need to create a display so we can undo that nasty summarizing stuff.
  #the code should probably go in the clustershell call area
  #print display.line_mode
  #exit(1)

  cs_ns = NodeSet(args.nodes)

  #for i in cs_ns:
  #  print i

  if args.worker == 0:
    logging.debug("We are the hierarchy caller")
    #we are being called to orchestrate a clustershell call
    #run_clustershell_command("/home/muzyncj/phoenix/bin/phoenix_power", cs_ns, arguments)
    run_clustershell_command("phoenix_power", cs_ns, arguments)
  elif args.worker == 1:
    logging.debug("We are the worker")
    #we are being called to do real work
    #TODO: change to power, _do_req will become generic
    rc = run_local_threaded_command(power, cs_ns, arguments)
    if rc > 0:
      print "We timed out on {0} node(s).".format(rc)

  rc = 0

  sys.exit(rc)
